var PadSide = {
	Left: "left",
	Right: "right"	
};

var PadType = {
	Human: 0x01,
	Computer: 0x02
};

var MoveMode = {
  Arcade: 0x01, // Keyboard UP/DOWN with linear moves
  Mouse: 0x02   // mouse moves
}

class PadBehavior extends Sup.Behavior {
  
  side = PadSide.Left;
  type = PadType.Human;
  moveMode = MoveMode.Mouse;
  size: Vec2 = {x: 0.1, y : 0.52};
  speed = 0.04;
  
  awake() {
    if (Game.entities.pad == null) {
      Game.entities.pad = this;
    }
    else {
      this.side = PadSide.Right;
      this.type = PadType.Computer;
      Game.entities.cpuPad = this;
    }
  }

  update() {
    var position = this.actor.getPosition();
    if (this.type == PadType.Human) {
      if (this.moveMode == MoveMode.Arcade) {
        if (Sup.Input.isKeyDown("UP")) {
          this.moveUp(null);
        }
        if (Sup.Input.isKeyDown("DOWN")) {
          this.moveDown(null);
        }
      }
      else if (this.moveMode == MoveMode.Mouse) {
        var mousePosition = Sup.Input.getMousePosition();
        // Sup.log(mousePosition);
        var padMousePos = mousePosition.y * (Game.entities.grid.size.y / 2);
        var difference = Math.abs(padMousePos - position.y);
        if (padMousePos > position.y) {
          this.moveUp(difference);
        }
        else {
          this.moveDown(difference);
        }
      }
    }
    
    var ball = Game.entities.ball;
    var ballPosition = ball.actor.getPosition();
    var position = this.actor.getPosition();
    if (this.side == PadSide.Left) {
      if (ball.velocity.x < 0 &&
          ballPosition.x - (ball.size.x/2) < position.x + (this.size.x/2) && // inside from right side
          ballPosition.x + (ball.size.x/2) > position.x - (this.size.x/2) && // inside from left side
          ballPosition.y - (ball.size.y/2) < position.y + (this.size.y/2) && // inside from top side
          ballPosition.y + (ball.size.y/2) > position.y - (this.size.y/2)) { // inside from bottom side
        ball.velocity.x = - ball.velocity.x;
        ball.velocity.y -= (position.y - ballPosition.y) * 0.05;
      }
    }
    else if (this.side == PadSide.Right) {
      if (ball.velocity.x > 0 &&
          ballPosition.x - (ball.size.x/2) < position.x + (this.size.x/2) && // inside from right side
          ballPosition.x + (ball.size.x/2) > position.x - (this.size.x/2) && // inside from left side
          ballPosition.y - (ball.size.y/2) < position.y + (this.size.y/2) && // inside from top side
          ballPosition.y + (ball.size.y/2) > position.y - (this.size.y/2)) { // inside from bottom side
        ball.velocity.x = - ball.velocity.x * 1.1;
        ball.velocity.y -= (position.y - ballPosition.y) * 0.05;
      }
    }
  }

  moveUp(ammount: number) {
    if (ammount == null) {
      ammount = this.speed;
    }
    var distance = Math.min(ammount, (Game.entities.grid.size.y/2) - (this.actor.getPosition().y + (this.size.y / 2)));
    this.actor.move(new Sup.Math.Vector3(0, distance, 0));
  }

  moveDown(ammount: number) {
    if (ammount == null) {
      ammount = this.speed;
    }
    var distance = Math.max(-ammount, (-Game.entities.grid.size.y/2) - (this.actor.getPosition().y - (this.size.y / 2)));
        this.actor.move(new Sup.Math.Vector3(0, distance, 0));
  }
}
Sup.registerBehavior(PadBehavior);
