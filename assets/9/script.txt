var PadSide = {
	Left: "left",
	Right: "right"	
};

var PadType = {
	Human: 0x01,
	Computer: 0x02
};

var MoveMode = {
  Arcade: 0x01, // Keyboard UP/DOWN with linear moves
  Mouse: 0x02, // mouse moves
  Teleport: 0x03 // pad jumps to positions
}

class PadBehavior extends Sup.Behavior {
  
  side = PadSide.Left;
  type = PadType.Human;
  moveMode = MoveMode.Arcade;
  size: Vec2 = {x: 0.1, y : 0.54};
  speed = 0.04;
  teleportSpeed = 0.186;
  angularSpeed = 0;
  
  awake() {
    if (Game.entities.pad == null) {
      Game.entities.pad = this;
    }
    else {
      this.side = PadSide.Right;
      this.type = PadType.Computer;
      Game.entities.cpuPad = this;
    }
  }

  update() {
    var position = this.actor.getPosition();
    if (this.type == PadType.Human) {
      if (this.moveMode == MoveMode.Arcade) {
        if (Sup.Input.isKeyDown("UP")) {
          this.moveUp(null);
        }
        if (Sup.Input.isKeyDown("DOWN")) {
          this.moveDown(null);
        }
      }
      else if (this.moveMode == MoveMode.Mouse) {
        var mousePosition = Sup.Input.getMousePosition();
        // Sup.log(mousePosition);
        var padMousePos = mousePosition.y * (Game.entities.grid.size.y / 2);
        var difference = Math.abs(padMousePos - position.y);
        if (padMousePos > position.y) {
          this.moveUp(difference);
        }
        else {
          this.moveDown(difference);
        }
      }
      else if (this.moveMode == MoveMode.Teleport) {
        if (Sup.Input.wasKeyJustPressed("UP")) {
          this.speed = this.teleportSpeed;
        }
        if (Sup.Input.wasKeyJustPressed("DOWN")) {
          this.speed = this.teleportSpeed;
        }
        
        if (Sup.Input.isKeyDown("UP")) {
          this.speed /= 1 + (0.2 * Game.replay);
          this.moveUp(null);
        }
        if (Sup.Input.isKeyDown("DOWN")) {
          this.speed /= 1 + (0.2 * Game.replay);
          this.moveDown(null);
        }
      }
    }
    
    var ball = Game.entities.ball;
    var ballPosition = ball.actor.getPosition();
    var position = this.actor.getPosition();
    if (this.side == PadSide.Left) {
      if (ball.velocity.x < 0 &&
          ballPosition.x - (ball.size.x/2) < position.x + (this.size.x/2) && // inside from right side
          ballPosition.x + (ball.size.x/2) > position.x - (this.size.x/2) && // inside from left side
          ballPosition.y - (ball.size.y/2) < position.y + (this.size.y/2) && // inside from top side
          ballPosition.y + (ball.size.y/2) > position.y - (this.size.y/2)) { // inside from bottom side
        this.angularSpeed += ball.velocity.x * 2 * Game.replay;
        //ball.velocity.x = - ball.velocity.x;
        //ball.velocity.y -= (position.y - ballPosition.y) * 0.05; 
        ball.bounceWithNormalAngle(0 - ((position.y - ballPosition.y) * 0.5));
        ball.changeRotation();
      }
    }
    else if (this.side == PadSide.Right) {
      if (ball.velocity.x > 0 &&
          ballPosition.x - (ball.size.x/2) < position.x + (this.size.x/2) && // inside from right side
          ballPosition.x + (ball.size.x/2) > position.x - (this.size.x/2) && // inside from left side
          ballPosition.y - (ball.size.y/2) < position.y + (this.size.y/2) && // inside from top side
          ballPosition.y + (ball.size.y/2) > position.y - (this.size.y/2)) { // inside from bottom side
        this.angularSpeed += ball.velocity.x * 2 * Game.replay;
        //ball.velocity.x = - ball.velocity.x * 1.1;
        //ball.velocity.y -= (position.y - ballPosition.y) * 0.05;
        ball.bounceWithNormalAngle(Math.PI + ((position.y - ballPosition.y) * 0.5));
        ball.changeRotation();
      }
    }
    
    var euler = this.actor.getLocalEulerAngles();
    if (euler.y > 0) {
      this.angularSpeed -= Math.min(0.01, euler.y) * Game.replay;
      this.angularSpeed *= 1 - (0.04 * Game.replay) * Game.replay;
    }
    else if (euler.y < 0) {
      this.angularSpeed += Math.min(0.01, -euler.y) * Game.replay;
      this.angularSpeed *= 1 - (0.04 * Game.replay) * Game.replay;
    }
    
    
    euler.y += this.angularSpeed;
    this.actor.setLocalEulerAngles(euler);
  }

  moveUp(ammount: number) {
    if (ammount == null) {
      ammount = this.speed;
    }
    var distance = Math.min(ammount, (Game.entities.grid.size.y/2) - (this.actor.getPosition().y + (this.size.y / 2)));
    this.actor.move(new Sup.Math.Vector3(0, distance * Game.replay, 0));
  }

  moveDown(ammount: number) {
    if (ammount == null) {
      ammount = this.speed;
    }
    var distance = Math.max(-ammount, (-Game.entities.grid.size.y/2) - (this.actor.getPosition().y - (this.size.y / 2)));
        this.actor.move(new Sup.Math.Vector3(0, distance * Game.replay, 0));
  }
}
Sup.registerBehavior(PadBehavior);
